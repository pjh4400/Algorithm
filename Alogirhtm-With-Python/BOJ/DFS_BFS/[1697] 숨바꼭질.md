# [1697] 숨바꼭질  

| 시간 제한 | 메모리 제한 | 제출   | 정답  | 맞힌 사람 | 정답 비율 |
| :-------- | :---------- | :----- | :---- | :-------- | :-------- |
| 2 초      | 128 MB      | 130744 | 36935 | 23087     | 25.028%   |

## 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

## 출력

수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

## 예제 입력 1

```
5 17
```

## 예제 출력 1

```
4
```

## 힌트

수빈이가 5-10-9-18-17 순으로 가면 4초만에 동생을 찾을 수 있다.



## 💡 구현 아이디어

- 구해야하는 것 : 수빈이가 동생을 찾을 수 있는 **가장 빠른 시간**
  - 최단거리문제 => BFS => 큐를 사용한 문제 (방문할 위치를 큐에 순서대로 넣는다)
- 이동할 수 있는 위치 : x-1, x+1, x*2
- 예제 
  - 0초 : [5]
  - 1초 : [4, 6, 10]
  - 2초 : 3, 5, 8 / 5, 7, 12 / 9, 11, 20 => [3, 8, 7, 9, 11, 20]
  - 3초 : [2, 16, 14, 10, 19, 21, 40]
  - 4초 : [1, 15, **17**, ...]

- 해당 위치에 가장 빨리 이동한 시간이 필요하다. 
  - 시간(거리) 기록 :  `distance[]` 필요
    - n, k 모두 최소값 0, 최대값 100000 를 가진다.(최대 100000 + 1 개의 위치)  : `모든 요소가 0으로 초기화 되어 있는 distance[100000+1] `
  - 이미 방문한 위치는 늦게 또 방문할 필요가 없다. => 시간이 0인 곳만 방문
  - k에 방문하면 시간(거리)을 출력하고 종료



## 🙆‍♀️ 내 풀이 (python)

```python
import sys
input = sys.stdin.readline

# 가장 빠른 시간 => 최단 거리 BFS
from collections import deque
def bfs(a):
  q = deque()
  q.append(a)
  while q:
    x = q.popleft()
    if x == k:
      break
    for nx in (x-1, x+1, x*2):
      if 0 <= nx <= MAX and distance[nx] == 0:
        distance[nx] = distance[x] + 1
        q.append(nx)
  return distance[k]

#  N, K (0 ≤ N, K ≤ 100,000)
MAX = 10 ** 5
n, k = map(int,input().split())
distance = [0] * (MAX+1)
print(bfs(n)) # n 위치에서 시작
```

