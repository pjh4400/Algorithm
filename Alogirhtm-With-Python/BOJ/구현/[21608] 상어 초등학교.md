# [21608] 상어 초등학교

문제 링크: https://www.acmicpc.net/problem/21608

category:  `구현`, `삼성 SW 역량 테스트`





## **💡 구현 아이디어**

주어진 조건에 맞추어 순서대로 조건문을 작성하면 되는 `구현`문제이다.

- 입력

  - 학생 번호에 해당하는 좋아하는 학생 리스트를 dictionary `likeStudents` 에 저장
  - 입력 학생 순서 `orders` 저장

- 풀이 로직

  - 교실 자리를 위한  `seats` 행렬 (초기값 0, 배정 후에는 학생 번호)

  - ```
    orders
    ```

     학생 순서대로 자리(

    ```
    seats
    ```

     에서의 좌표 (r,c)) 탐색

    - ```
      seats
      ```

       행렬을 순회하며 비어있는 칸(값이 0) 이면 조건 탐색

      1. 인접한 칸 에 좋아하는 학생 수가 더 많으면 교체
      2. 1이 같으면 인접한 칸에 비어있는 칸(값이 0)이 더 많으면 교체
      3. 2가 같으면 행의 번호가 더 작은 칸
      4. 3이 같으면 열의 번호가 더 작은 칸

- 출력

  - ```
    seats
    ```

     를 순회하며 해당 학생의 인접한 칸에 앉은 좋아하는 학생의 수 

    ```
    curCnt
    ```

    를 통해 만족도 

    ```
    score
    ```

     계산

    - `score` += 10**(`curCnt`-1)



## **🙆‍♀️ 내 풀이 (python)**

```python
import sys
input = sys.stdin.readline

# 입력
n = int(input().rstrip())
seats = [[0 for _ in range(n+1)] for _ in range(n+1)]
likeStudents = {} # 
orders = [] # 순서 저장
for _ in range(n*n):
  line = list(map(int,input().split()))
  likeStudents[line[0]] = line[1:]
  orders.append(line[0])

dx = [0,0,-1,1] #행
dy = [-1,1,0,0] #열
likeCnt = 0
emptyCnt = 0
mySeat = [0,0] # 앉을자리(행,열)
for x in orders: # 학생 입력 순서대로
  myLikeStudents = likeStudents[x]
  maxLikeCnt = -1 # 인접 최대 좋아하는 학생 수
  maxEmptyCnt = -1 # 인접 최대 비어있는 칸 수
  # 칸 별로 체크해서 비어있는 칸이면 인접 좋아하는 학생수, 비어있는 칸 수 체크
  for r in range(1,n+1):
    for c in range(1,n+1):
      if seats[r][c] == 0: # 비어있는 칸이면
        for i in range(4):
          # 범위 체크
          nr = r+dx[i]
          nc = c+dy[i]
          if nr <= 0 or nr > n or nc <= 0 or nc > n:
            continue
          # 인접 비어있는 칸 수 계산
          if seats[nr][nc] == 0:
            emptyCnt += 1
          # 인접 좋아하는 학생수 계산
          elif seats[nr][nc] in myLikeStudents:
            likeCnt += 1    
        if maxLikeCnt < likeCnt: # 1. 좋아하는 학생 수가 더 많으면 교체
          maxLikeCnt = likeCnt
          maxEmptyCnt = emptyCnt
          mySeat = [r,c]
        elif maxLikeCnt == likeCnt: # 2. 1이 같으면 비어있는 칸 수가 더 많으면 교체
          if maxEmptyCnt < emptyCnt: 
            maxLikeCnt = likeCnt
            maxEmptyCnt = emptyCnt
            mySeat = [r,c]
          elif maxEmptyCnt == emptyCnt: # 3. 2가 같으면 행, 열 번호 체크
            if r < mySeat[0]: # 행번호가 더 작은
              maxLikeCnt = likeCnt
              maxEmptyCnt = emptyCnt
              mySeat = [r,c]
            elif r == mySeat[0]:
              if c < mySeat[1]: # 열번호가 더 작은
                maxLikeCnt = likeCnt
                maxEmptyCnt = emptyCnt
                mySeat = [r,c]
      # 값 초기화
      likeCnt = 0
      emptyCnt = 0
  seats[mySeat[0]][mySeat[1]] = x # 자리 배정

# 출력: 학생만족도 총합
score = 0
# 학생의 만족도: 10^(좋아하는학생수-1) 0이면 0
for r in range(1,n+1):
  for c in range(1,n+1):
    x = seats[r][c]
    myLikeStudents = likeStudents[x]
    curCnt = 0
    for i in range(4):
        # 1. 좋아하는 학생수 체크
        nr = r+dx[i]
        nc = c+dy[i]
        if nr <= 0 or nr > n or nc <= 0 or nc > n:
          continue
        if seats[nr][nc] in myLikeStudents:
          curCnt += 1
    if curCnt > 0:
      score += 10**(curCnt-1)

print(score)
```



## 📌 체크포인트

1. 조건이 많을 경우 조건문을 확실히 확인하고 명시하자
2. 값이 바뀔 경우 관련된 모든 값을 변경해주자.
   - 본 문제에서는 자리 `mySeat` 가 바뀔 경우 `maxLikeCnt` , `maxEmptyCnt` 도 변경해주어야 한다.

```python
elif r == mySeat[0]: # 빼먹었던 부분! 행 번호가 같을 경우에만 열을 체크한다.
    if c < mySeat[1]:
      maxLikeCnt = likeCnt
      maxEmptyCnt = emptyCnt
      mySeat = [r,c]
```

1. 최대값은 초기값을 될 수 있는 값의 최소값(본 문제에서는 0)보다 작게 하자.

```python
maxLikeCnt = -1 # 인접 최대 좋아하는 학생 수
maxEmptyCnt = -1 # 인접 최대 비어있는 칸 수
```