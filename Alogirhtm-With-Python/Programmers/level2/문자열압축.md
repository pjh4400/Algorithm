# [level2] 문자열압축

문제 링크: https://programmers.co.kr/learn/courses/30/lessons/60057?language=python3



## **💡 구현 아이디어**

------

- 문자열 압축과정의 단위를 1개 ~ 문자열길이 만큼 진행해야한다.

  → 압축(press 함수) 를 단위 별로 호출

- 문자열이 반복되는지 비교하기 위해 이전 문자열을 저장해야한다. → `pre_s`

- 문자열이 반복된다면, 반복횟수를 증가시켜야한다. → `cnt`

- 반복되지 않는다면, 반복횟수를 초기화하고, 이전 문자열을 바꾼다.



## 🙆‍♀️ 내 풀이 (python)

------

```python
# 문자열을 l 개 단위로 잘라 압축
def press(s,l):
    cur_s = "" # 현재 문자열
    pre_s = s[:l] # 반복 문자열
    cnt = 1 # 이전 반복 횟수
    for i in range(l,len(s),l):
        # 문자열 반복 O
        if pre_s == s[i:i+l]:
            cnt += 1
        # 문자열 반복 X
        else:
            if cnt > 1: # 이전 반복 O
                cur_s += str(cnt)
            cur_s += pre_s
            pre_s = s[i:i+l]
            cnt = 1
    
    if cnt > 1: # 반복일 경우
        cur_s += str(cnt) + pre_s
    else: # 반복이 아닐 경우
        cur_s += pre_s
    return len(cur_s)

def solution(s):
    answer = len(s) # 최소값을 구해야하므로 초기값은 최대값으로 설정 
    for i in range(1,len(s)):
        answer = min(answer,press(s,i))         
    return answer
```



## 📌 체크포인트

1. answer 의 초기값을 1000으로 해서 실패 (s의 길이는 1 이상 1,000 이하 라는 조건을 보고 설정)

   → s의 길이가 1일 경우 solution 의 반복문을 돌지 않아 answer 가 1000이 된다.

   → 전체의 최대가 아니라 **케이스 별 최대값**을 고려하자!

2. 슬라이스(slice)의 경우 **끝 인덱스는 범위를 벗어난 인덱스를 지정할 수 있다.**

   ex) s의 길이가 8일 때 s[:14] 를 하더라도 s와 같다.