```python
def solution(n, lost, reserve):
  for x in lost:
    if x in reserve:
      reserve.remove(x)
      lost.remove(x)

  answer = n - len(lost)
  for x in lost:
    if x-1 in reserve:
      reserve.remove(x-1)
      answer += 1
    elif x+1 in reserve:
      reserve.remove(x+1)
      answer += 1

  return answer
```



```python
def solution(n, lost, reserve):

  real_lost = [l for l in lost if l not in reserve]
  real_reserve = [r for r in reserve if r not in lost]

  answer = n - len(real_lost)
  for x in real_lost:
    if x-1 in real_reserve:
      real_reserve.remove(x-1)
      answer += 1
    elif x+1 in real_reserve:
      real_reserve.remove(x+1)
      answer += 1

  return answer
```





````python

def solution(name):
  answer = -1
  cur = 'A' * len(name)
  if cur == name:
    return 0

  if name[1] == 'A' and name[-1] != 'A':
    name = name[0] + name[-1:0:-1]

  for i, x in enumerate(name):
    answer += 1
    if x == 'A':
      if i == len(name)-1:
        answer -= 1
      continue

    ascx = ord(x)
    if ascx - ord('A') <= ord('Z') - ascx:
      answer += ascx - ord('A')
    else:
      answer += ord('Z') - ascx + 1

  # 처음 꺼 빼고
  return answer

print(solution("AAA"))
````



```python
#작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리
#1. 요청순서대로
#2. 요청시간 + 작업소요시간보다 작은 요청시간 중 소요시간 짧은 것

def solution(jobs):
    answer = 0
    jobs = sorted(jobs)
    timer = jobs[0][0]
    t_sum = 0
    for i in range(len(jobs)):
      timer += jobs[i][1]
      t_sum += timer - jobs[i][0]
      for x in jobs[i+1:]:
        if x[0] <= timer:
          
      

    answer = t_sum / len(jobs)
    return answer

print(solution([[0, 3], [1, 9], [2, 6]]))
```





# 입국심사

순차 탐색

```python
# 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다.
# 모든 사람이 심사를 받는데 걸리는 시간을 최소 => 

def solution(n, times):
    timer = 0
    # 심사관 수
    judging = times.copy()
    n -= len(times)
    while n >= 0: # 모두 받을 떄까지
      timer += 1 # 시간 경과
      for i in range(len(judging)):
        judging[i] -= 1
        # 심사 끝나면 다음 사람 심사시작
        # 여기서 판단. 어디가 더 이득?
        if judging[i] <= 0: 
          n -= 1
          judging[i] = times[i] 
        if n < 0:

          break
      print(timer,n,judging)
  

    return timer

print(solution(6,[7, 10]))
```



구해야하는 것: 모든 사람이 심사를 받는데 걸리는 시간의 최솟값

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.

- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.

  => 범위 매우 넓음. 순차탐색 어려움 => 이분탐색



timer 는 



```python
def binary_search(array, target, start, end):
  while start <= end:
      mid = (start + end) // 2
      if array[mid] == target:
          return mid
      elif array[mid] > target:
          end = mid - 1
      else:
          start = mid + 1
  return None

def solution(n, times):
    timer = 0
    ㄴㅅㅁㄳ
    while start <= end:
      mid = (start + end) // 2
      if array[mid] == target:
          return mid
      elif array[mid] > target:
          end = mid - 1
      else:
          start = mid + 1

    while n >= 0: # 모두 받을 떄까지
      timer += 1 # 시간 경과
      for i in range(len(judging)):
        judging[i] -= 1
        # 심사 끝나면 다음 사람 심사시작
        # 여기서 판단. 어디가 더 이득?
        if judging[i] <= 0: 
          n -= 1
          judging[i] = times[i] 
        if n < 0:

          break
      print(timer,n,judging)
  

    return timer
```





## 징검다리

- 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하: 범위 매우 큼 => 선형 탐색 불가(원래는 배열 정렬 후 잘라내고, 순회하면서 하나씩 옆 바위랑 거리를 구해야한다.) n^n

  => 거리를 정해놓고

```python

```

